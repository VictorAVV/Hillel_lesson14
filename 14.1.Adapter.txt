1. Как с технической точки зрения реализован основной принцип шаблона “Адаптер”?
<?php
/**
 * Целевой класс объявляет интерфейс, с которым может работать клиентский код.
 */
class Target
{
    public function request(): string
    {
        return "Target: The default target's behavior.";
    }
}
/**
 * Адаптируемый класс содержит некоторое полезное поведение, но его интерфейс
 * несовместим  с существующим клиентским кодом. Адаптируемый класс нуждается в
 * некоторой доработке,  прежде чем клиентский код сможет его использовать.
 */
class Adaptee
{
    public function specificRequest(): string
    {
        return ".eetpadA eht fo roivaheb laicepS";
    }
}
/**
 * Адаптер делает интерфейс Адаптируемого класса совместимым с целевым
 * интерфейсом.
 */
class Adapter extends Target
{
    private $adaptee;

    public function __construct(Adaptee $adaptee)
    {
        $this->adaptee = $adaptee;
    }

    public function request(): string
    {
        return "Adapter: (TRANSLATED) " . strrev($this->adaptee->specificRequest());
    }
}
/**
 * Клиентский код поддерживает все классы, использующие целевой интерфейс.
 */
function clientCode(Target $target)
{
    echo $target->request();
}

echo "Client: I can work just fine with the Target objects:\n";
$target = new Target;
clientCode($target);
echo "\n\n";
$adaptee = new Adaptee;
echo "Client: The Adaptee class has a weird interface. See, I don't understand it:\n";
echo "Adaptee: " . $adaptee->specificRequest();
echo "\n\n";
echo "Client: But I can work with it via the Adapter:\n";
$adapter = new Adapter($adaptee);
clientCode($adapter);
?>

Шаблон "Адаптер" используется как "прослойка" между клиентским кодом и исходным классом, интерфейс которого несовместим или частично несовместим (содержит методы или свойства, которые не могут быть напрямую использованы в клиентском коде) с этим кодом.

В вышеприведенном примере кода:
- класс Target - это целевой класс - пример того, что хочет клиент - чтобы методом request() возаращались данные в определенном виде;
- класс Adaptee - это имеющийся у нас класс, который возвращает нужные данные, но в неправильном виде;
- класс Adapter - класс-наследник целевого класса Target, который берет данные у существующего класса Adaptee и приводит их к нужному для клиента виду.

В классе-наследнике Adapter, создается метод с тем же именем, что и в целевом классе Target. Этот метод берет нужные данные от исходного класса Adaptee, преобразовует их и отдает клиенту.

Для преобразования данных в нужный вид в классе "Адаптер" созданы: 
- приватная переменная $adaptee, в которой хранится исходный объект Adaptee (который возвращает необходимые данные, но в неправильном виде);
- конструктор, в котором в переменную $adaptee помещается исходный объект Adaptee;
- нужный клиенту метод request(), который берет нужные данные от нужного метода (в исходном объекте Adaptee), преобразовует эти данные в нужную для клиента форму и отдает эти преобразованные данные клиенту.

Для использования адаптера необходимо:
1) создать экземпляр исходного класса Adaptee (который отдает нужные данные в неправильном виде);
   > $adaptee = new Adaptee;
2) создать экземпляр класса Adapter (который является наследником целевого класса Target) и передать в него экземпляр исходного класса Adaptee;
   > $adapter = new Adapter($adaptee);
3) вызвать нужный клиенту метод request(), который вернет данные в нужном для клиента виде (экземпляр класса Adapter будет выполнять внтури себя нужные переобразования).
   > $adapter->request();
